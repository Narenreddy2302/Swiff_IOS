//
//  AnalyticsServiceAgent14.swift
//  Swiff IOS
//
//  Created by Agent 14 on 11/21/25.
//  Comprehensive analytics service for subscription tracking, forecasting, and insights
//  NOTE: This will be merged with Agent 6's AnalyticsService by Integration Agent Alpha
//
//  IMPLEMENTATION STATUS: ALL 17 TASKS COMPLETED
//  - Task 2: calculateSpendingTrends(for:) âœ…
//  - Task 3: calculateMonthlyAverage() âœ…
//  - Task 4: calculateYearOverYearChange() âœ…
//  - Task 5: calculateCategoryBreakdown() âœ…
//  - Task 6: getTopCategories(limit:) âœ…
//  - Task 7: getTotalMonthlyCost() âœ…
//  - Task 8: getAverageCostPerSubscription() âœ…
//  - Task 9: getMostExpensiveSubscriptions(limit:) âœ…
//  - Task 10: forecastSpending(months:) âœ…
//  - Task 11: predictNextMonthSpending() âœ…
//  - Task 12: detectUnusedSubscriptions(threshold:) âœ…
//  - Task 13: detectPriceIncreases(within:) âœ…
//  - Task 14: detectTrialsEndingSoon(within:) âœ…
//  - Task 15: generateSavingsOpportunities() âœ…
//  - Task 16: suggestCancellations() âœ…
//  - Task 17: suggestAnnualConversions() âœ…
//

import Foundation
import Combine

/// Main analytics service providing spending trends, forecasting, and recommendations
@MainActor
class AnalyticsServiceAgent14: ObservableObject {

    // MARK: - Singleton
    static let shared = AnalyticsServiceAgent14()

    // MARK: - Dependencies
    private let dataManager = DataManager.shared

    // MARK: - Cache Properties
    private var cachedSpendingTrends: [DateRange: [DateValue]] = [:]
    private var cachedCategoryBreakdown: [CategorySpending]?
    private var cachedMonthlyAverage: Double?
    private var cachedForecast: (months: Int, values: [ForecastValue])?
    private var cacheTimestamp: Date?
    private let cacheTimeout: TimeInterval = 300 // 5 minutes

    // MARK: - Published Properties
    @Published var isCalculating = false
    @Published var lastError: Error?

    // MARK: - Initialization
    private init() {}

    // MARK: - Cache Management

    /// Clear all cached analytics data
    func clearCache() {
        cachedSpendingTrends.removeAll()
        cachedCategoryBreakdown = nil
        cachedMonthlyAverage = nil
        cachedForecast = nil
        cacheTimestamp = nil
        print("ðŸ“Š Analytics cache cleared")
    }

    /// Check if cache is valid
    private var isCacheValid: Bool {
        guard let timestamp = cacheTimestamp else { return false }
        return Date().timeIntervalSince(timestamp) < cacheTimeout
    }

    /// Invalidate cache
    private func invalidateCache() {
        clearCache()
    }

    // MARK: - Task 2: Spending Trends

    /// Calculate spending trends for a date range
    /// Returns array of date-value pairs showing spending over time
    func calculateSpendingTrends(for dateRange: DateRange) -> [DateValue] {
        // Check cache first
        if isCacheValid, let cached = cachedSpendingTrends[dateRange] {
            return cached
        }

        let subscriptions = dataManager.subscriptions.filter { $0.isActive }
        let startDate = dateRange.startDate
        let endDate = dateRange.endDate

        // Generate date points based on range
        let calendar = Calendar.current
        var dates: [Date] = []
        var currentDate = startDate

        // Determine interval based on range
        let component: Calendar.Component
        switch dateRange {
        case .week:
            component = .day
        case .month:
            component = .day
        case .quarter:
            component = .weekOfYear
        case .year:
            component = .month
        case .custom:
            let daysDiff = calendar.dateComponents([.day], from: startDate, to: endDate).day ?? 0
            component = daysDiff > 90 ? .month : (daysDiff > 30 ? .weekOfYear : .day)
        }

        // Generate date array
        while currentDate <= endDate {
            dates.append(currentDate)
            currentDate = calendar.date(byAdding: component, value: 1, to: currentDate) ?? endDate
        }

        // Calculate spending for each date point
        let trends = dates.map { date -> DateValue in
            let spending = calculateSpending(for: subscriptions, at: date)
            return DateValue(date: date, amount: spending)
        }

        // Cache results
        cachedSpendingTrends[dateRange] = trends
        cacheTimestamp = Date()

        return trends
    }

    /// Helper: Calculate spending at a specific date
    private func calculateSpending(for subscriptions: [Subscription], at date: Date) -> Double {
        subscriptions.reduce(0.0) { total, subscription in
            // Only count if subscription was active at this date
            guard subscription.createdDate <= date else { return total }
            if let cancellationDate = subscription.cancellationDate, cancellationDate < date {
                return total
            }
            return total + subscription.monthlyEquivalent
        }
    }

    // MARK: - Task 3: Monthly Average

    /// Calculate monthly average spending
    /// Returns average monthly cost across all active subscriptions
    func calculateMonthlyAverage() -> Double {
        if isCacheValid, let cached = cachedMonthlyAverage {
            return cached
        }

        let monthlyTotal = getTotalMonthlyCost()
        cachedMonthlyAverage = monthlyTotal
        cacheTimestamp = Date()

        return monthlyTotal
    }

    // MARK: - Task 4: Year Over Year Change

    /// Calculate year-over-year change in spending
    /// Returns percentage change (positive = increase, negative = decrease)
    func calculateYearOverYearChange() -> Double {
        let currentYear = calculateSpendingForYear(Date())
        let lastYear = calculateSpendingForYear(Calendar.current.date(byAdding: .year, value: -1, to: Date()) ?? Date())

        guard lastYear > 0 else { return 0 }

        let change = ((currentYear - lastYear) / lastYear) * 100
        return change
    }

    /// Helper: Calculate total spending for a year
    private func calculateSpendingForYear(_ date: Date) -> Double {
        let calendar = Calendar.current
        guard let startOfYear = calendar.date(from: calendar.dateComponents([.year], from: date)),
              let endOfYear = calendar.date(byAdding: DateComponents(year: 1, day: -1), to: startOfYear) else {
            return 0
        }

        return dataManager.subscriptions.reduce(0.0) { total, subscription in
            // Check if subscription was active during this year
            guard subscription.createdDate <= endOfYear else { return total }
            if let cancellationDate = subscription.cancellationDate, cancellationDate < startOfYear {
                return total
            }

            // Calculate months active in this year
            let subscriptionStart = max(subscription.createdDate, startOfYear)
            let subscriptionEnd = min(subscription.cancellationDate ?? endOfYear, endOfYear)

            let monthsActive = calendar.dateComponents([.month], from: subscriptionStart, to: subscriptionEnd).month ?? 0

            return total + (subscription.monthlyEquivalent * Double(max(monthsActive, 1)))
        }
    }

    // MARK: - Task 5-6: Category Analysis

    /// Calculate category breakdown with spending percentages
    func calculateCategoryBreakdown() -> [CategorySpending] {
        if isCacheValid, let cached = cachedCategoryBreakdown {
            return cached
        }

        let activeSubscriptions = dataManager.subscriptions.filter { $0.isActive }
        let totalMonthlyCost = getTotalMonthlyCost()

        // Group by category
        var categoryMap: [SubscriptionCategory: (total: Double, count: Int)] = [:]

        for subscription in activeSubscriptions {
            let monthly = subscription.monthlyEquivalent
            if let existing = categoryMap[subscription.category] {
                categoryMap[subscription.category] = (existing.total + monthly, existing.count + 1)
            } else {
                categoryMap[subscription.category] = (monthly, 1)
            }
        }

        // Convert to CategorySpending
        let breakdown = categoryMap.map { category, data in
            CategorySpending(
                category: category,
                totalAmount: data.total,
                percentage: totalMonthlyCost > 0 ? (data.total / totalMonthlyCost) * 100 : 0,
                count: data.count
            )
        }.sorted { $0.totalAmount > $1.totalAmount }

        cachedCategoryBreakdown = breakdown
        cacheTimestamp = Date()

        return breakdown
    }

    /// Get top N categories by spending
    func getTopCategories(limit: Int) -> [CategorySpending] {
        let breakdown = calculateCategoryBreakdown()
        return Array(breakdown.prefix(limit))
    }

    // MARK: - Task 7-9: Subscription Analytics

    /// Get total monthly cost of all active subscriptions
    func getTotalMonthlyCost() -> Double {
        return dataManager.calculateTotalMonthlyCost()
    }

    /// Get average cost per subscription
    func getAverageCostPerSubscription() -> Double {
        let activeSubscriptions = dataManager.subscriptions.filter { $0.isActive }
        guard !activeSubscriptions.isEmpty else { return 0 }

        let total = getTotalMonthlyCost()
        return total / Double(activeSubscriptions.count)
    }

    /// Get most expensive subscriptions
    func getMostExpensiveSubscriptions(limit: Int) -> [Subscription] {
        return dataManager.subscriptions
            .filter { $0.isActive }
            .sorted { $0.monthlyEquivalent > $1.monthlyEquivalent }
            .prefix(limit)
            .map { $0 }
    }

    // MARK: - Task 10-11: Forecasting

    /// Forecast spending for future months using linear regression
    /// Algorithm: Uses simple moving average with trend analysis
    func forecastSpending(months: Int) -> [ForecastValue] {
        // Check cache
        if isCacheValid, let cached = cachedForecast, cached.months == months {
            return cached.values
        }

        // Get historical data (last 12 months)
        let historicalTrends = calculateSpendingTrends(for: .year)

        guard historicalTrends.count >= 3 else {
            // Not enough data, use current spending
            let currentMonthly = getTotalMonthlyCost()
            return generateFlatForecast(months: months, amount: currentMonthly)
        }

        // Calculate trend using simple linear regression
        let (slope, intercept) = calculateLinearRegression(from: historicalTrends)

        let calendar = Calendar.current
        var forecasts: [ForecastValue] = []

        for month in 1...months {
            guard let futureDate = calendar.date(byAdding: .month, value: month, to: Date()) else { continue }

            // Predict using linear model
            let x = Double(historicalTrends.count + month)
            let predicted = max(0, slope * x + intercept)

            // Calculate confidence (decreases over time)
            let confidence = max(0.3, 1.0 - (Double(month) * 0.08))

            // Calculate bounds (Â±20% with decreasing confidence)
            let variance = predicted * 0.2 * (1.0 - confidence)
            let lowerBound = max(0, predicted - variance)
            let upperBound = predicted + variance

            forecasts.append(ForecastValue(
                date: futureDate,
                predictedAmount: predicted,
                confidence: confidence,
                lowerBound: lowerBound,
                upperBound: upperBound
            ))
        }

        cachedForecast = (months, forecasts)
        cacheTimestamp = Date()

        return forecasts
    }

    /// Predict next month's spending
    func predictNextMonthSpending() -> Double {
        let forecast = forecastSpending(months: 1)
        return forecast.first?.predictedAmount ?? getTotalMonthlyCost()
    }

    /// Helper: Calculate linear regression
    private func calculateLinearRegression(from trends: [DateValue]) -> (slope: Double, intercept: Double) {
        let n = Double(trends.count)
        var sumX = 0.0
        var sumY = 0.0
        var sumXY = 0.0
        var sumXX = 0.0

        for (index, trend) in trends.enumerated() {
            let x = Double(index)
            let y = trend.amount
            sumX += x
            sumY += y
            sumXY += x * y
            sumXX += x * x
        }

        let slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX)
        let intercept = (sumY - slope * sumX) / n

        return (slope, intercept)
    }

    /// Helper: Generate flat forecast
    private func generateFlatForecast(months: Int, amount: Double) -> [ForecastValue] {
        let calendar = Calendar.current
        var forecasts: [ForecastValue] = []

        for month in 1...months {
            guard let futureDate = calendar.date(byAdding: .month, value: month, to: Date()) else { continue }

            forecasts.append(ForecastValue(
                date: futureDate,
                predictedAmount: amount,
                confidence: 0.5,
                lowerBound: amount * 0.9,
                upperBound: amount * 1.1
            ))
        }

        return forecasts
    }

    // MARK: - Task 12-14: Detection Algorithms

    /// Detect unused subscriptions based on usage threshold
    /// Threshold: Number of days without usage
    func detectUnusedSubscriptions(threshold: Int = 30) -> [Subscription] {
        let cutoffDate = Calendar.current.date(byAdding: .day, value: -threshold, to: Date()) ?? Date()

        return dataManager.subscriptions.filter { subscription in
            guard subscription.isActive else { return false }

            // Check last used date
            if let lastUsed = subscription.lastUsedDate {
                return lastUsed < cutoffDate
            }

            // If never used and created more than threshold days ago
            return subscription.createdDate < cutoffDate && subscription.usageCount == 0
        }
    }

    /// Detect price increases within specified days
    func detectPriceIncreases(within days: Int = 30) -> [Subscription] {
        let cutoffDate = Calendar.current.date(byAdding: .day, value: -days, to: Date()) ?? Date()

        return dataManager.subscriptions.filter { subscription in
            guard subscription.isActive else { return false }
            guard let lastPriceChange = subscription.lastPriceChange else { return false }

            return lastPriceChange >= cutoffDate
        }
    }

    /// Detect trials ending soon within specified days
    func detectTrialsEndingSoon(within days: Int = 7) -> [Subscription] {
        let futureDate = Calendar.current.date(byAdding: .day, value: days, to: Date()) ?? Date()

        return dataManager.subscriptions.filter { subscription in
            guard subscription.isActive, subscription.isFreeTrial else { return false }
            guard let trialEndDate = subscription.trialEndDate else { return false }

            return trialEndDate <= futureDate && trialEndDate >= Date()
        }
    }

    // MARK: - Task 15-17: Recommendations

    /// Generate comprehensive savings opportunities
    func generateSavingsOpportunities() -> [SavingsSuggestion] {
        var suggestions: [SavingsSuggestion] = []

        // Unused subscriptions
        let unused = detectUnusedSubscriptions(threshold: 60)
        for subscription in unused {
            let annualSavings = subscription.monthlyEquivalent * 12
            suggestions.append(SavingsSuggestion(
                type: .unused,
                subscription: subscription,
                potentialSavings: annualSavings,
                description: "You haven't used this subscription in 60 days. Consider cancelling to save \(annualSavings.asCurrency)/year.",
                priority: annualSavings > 100 ? .high : .medium
            ))
        }

        // Annual conversion opportunities
        let annualOpportunities = suggestAnnualConversions()
        for opportunity in annualOpportunities {
            suggestions.append(SavingsSuggestion(
                type: .annualConversion,
                subscription: opportunity.subscription,
                potentialSavings: opportunity.annualSavings,
                description: "Switch to annual billing and save \(opportunity.annualSavings.asCurrency)/year (\(opportunity.monthlySavings.asCurrency)/month).",
                priority: opportunity.annualSavings > 50 ? .high : .medium
            ))
        }

        // Price increases
        let priceIncreases = detectPriceIncreases(within: 30)
        for subscription in priceIncreases {
            suggestions.append(SavingsSuggestion(
                type: .priceIncrease,
                subscription: subscription,
                potentialSavings: 0,
                description: "Price recently increased. Review if you still need this subscription.",
                priority: .medium
            ))
        }

        // Trials ending soon
        let trialsEnding = detectTrialsEndingSoon(within: 7)
        for subscription in trialsEnding {
            let cost = subscription.priceAfterTrial ?? subscription.price
            suggestions.append(SavingsSuggestion(
                type: .trialEnding,
                subscription: subscription,
                potentialSavings: cost * 12,
                description: "Trial ends soon. Cancel before \(subscription.trialEndDate?.formatted() ?? "trial end") to avoid charges.",
                priority: .urgent
            ))
        }

        return suggestions.sorted { $0.potentialSavings > $1.potentialSavings }
    }

    /// Suggest subscriptions for cancellation
    func suggestCancellations() -> [Subscription] {
        let unused = detectUnusedSubscriptions(threshold: 90)
        let trialsEnding = detectTrialsEndingSoon(within: 3)

        var candidates = Set<UUID>()
        unused.forEach { candidates.insert($0.id) }
        trialsEnding.forEach { candidates.insert($0.id) }

        return dataManager.subscriptions.filter { candidates.contains($0.id) }
    }

    /// Suggest annual conversions with savings calculations
    /// Assumes typical 16% discount for annual plans (2 months free)
    func suggestAnnualConversions() -> [AnnualSuggestion] {
        let monthlySubscriptions = dataManager.subscriptions.filter {
            $0.isActive && $0.billingCycle == .monthly && $0.price >= 5.0
        }

        return monthlySubscriptions.map { subscription in
            let currentMonthlyCost = subscription.price
            let annualCost = currentMonthlyCost * 10 // Typical: 10 months price for 12 months service

            return AnnualSuggestion(
                subscription: subscription,
                currentMonthlyCost: currentMonthlyCost,
                annualCost: annualCost
            )
        }.filter { $0.annualSavings > 10 } // Only suggest if saving at least $10/year
         .sorted { $0.annualSavings > $1.annualSavings }
    }

    // MARK: - Statistics

    /// Get comprehensive subscription statistics
    func getSubscriptionStatistics() -> SubscriptionStatistics {
        let activeSubscriptions = dataManager.subscriptions.filter { $0.isActive }
        let inactiveSubscriptions = dataManager.subscriptions.filter { !$0.isActive }

        let categoryBreakdown = calculateCategoryBreakdown()
        let mostExpensiveCategory = categoryBreakdown.first?.category.rawValue ?? "None"

        let renewals7 = dataManager.subscriptions.filter { subscription in
            guard subscription.isActive else { return false }
            let daysUntil = Calendar.current.dateComponents([.day], from: Date(), to: subscription.nextBillingDate).day ?? 0
            return daysUntil <= 7 && daysUntil >= 0
        }.count

        let renewals30 = dataManager.subscriptions.filter { subscription in
            guard subscription.isActive else { return false }
            let daysUntil = Calendar.current.dateComponents([.day], from: Date(), to: subscription.nextBillingDate).day ?? 0
            return daysUntil <= 30 && daysUntil >= 0
        }.count

        let freeTrials = dataManager.subscriptions.filter { $0.isActive && $0.isFreeTrial }.count
        let trialsEnding = detectTrialsEndingSoon(within: 7).count

        return SubscriptionStatistics(
            totalActive: activeSubscriptions.count,
            totalInactive: inactiveSubscriptions.count,
            totalMonthlyCost: getTotalMonthlyCost(),
            totalAnnualCost: getTotalMonthlyCost() * 12,
            mostExpensiveCategory: mostExpensiveCategory,
            averageCostPerSubscription: getAverageCostPerSubscription(),
            upcomingRenewals7Days: renewals7,
            upcomingRenewals30Days: renewals30,
            freeTrials: freeTrials,
            trialsEndingSoon: trialsEnding
        )
    }

    /// Get spending statistics with trend analysis
    func getSpendingStatistics() -> SpendingStatistics {
        let currentMonth = getTotalMonthlyCost()
        let monthlyAverage = calculateMonthlyAverage()

        // Calculate last month (simplified - uses current active subscriptions)
        let lastMonth = currentMonth // Could be enhanced with historical data

        let yearlyTotal = currentMonth * 12
        let percentageChange = lastMonth > 0 ? ((currentMonth - lastMonth) / lastMonth) * 100 : 0

        // Determine trend
        let trend: SpendingTrend
        if abs(percentageChange) < 5 {
            trend = .stable
        } else if percentageChange > 0 {
            trend = .increasing
        } else {
            trend = .decreasing
        }

        return SpendingStatistics(
            currentMonth: currentMonth,
            lastMonth: lastMonth,
            monthlyAverage: monthlyAverage,
            yearlyTotal: yearlyTotal,
            percentageChange: percentageChange,
            trend: trend
        )
    }
}

// MARK: - Currency Extension

extension Double {
    var asCurrency: String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.currencySymbol = "$"
        return formatter.string(from: NSNumber(value: self)) ?? "$0.00"
    }
}
