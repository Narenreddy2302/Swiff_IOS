//
//  AnalyticsService.swift
//  Swiff IOS
//
//  Created by Agent 6 on 11/21/25.
//  Comprehensive analytics service for dashboard
//

import Foundation
import SwiftUI

// MARK: - AGENT 6: Analytics Service

@MainActor
class AnalyticsService: ObservableObject {

    // MARK: - Singleton
    static let shared = AnalyticsService()

    // MARK: - Private Properties
    private let dataManager = DataManager.shared

    // MARK: - Initialization
    private init() {}

    // MARK: - AGENT 6: Spending Trends Calculation

    /// Calculate spending trends for a given date range
    /// Returns data points for plotting on charts
    func calculateSpendingTrends(for dateRange: DateRange) -> [SpendingDataPoint] {
        let startDate = dateRange.startDate
        let endDate = dateRange.endDate

        // Get all subscriptions and transactions in date range
        let subscriptions = dataManager.subscriptions.filter { $0.isActive }
        let transactions = dataManager.transactions.filter { transaction in
            transaction.date >= startDate && transaction.date <= endDate
        }

        // Group by date buckets (daily, weekly, or monthly depending on range)
        let bucketSize = determineBucketSize(for: dateRange)
        var dataPoints: [Date: (subscriptions: Double, transactions: Double)] = [:]

        // Process subscriptions - calculate monthly equivalent for each date
        let calendar = Calendar.current
        var currentDate = startDate
        while currentDate <= endDate {
            let monthlyTotal = subscriptions.reduce(0.0) { total, sub in
                total + sub.monthlyEquivalent
            }
            dataPoints[currentDate] = (monthlyTotal, 0.0)
            currentDate = calendar.date(byAdding: bucketSize.component, value: 1, to: currentDate) ?? endDate
        }

        // Process transactions
        for transaction in transactions {
            let bucketDate = bucketDate(for: transaction.date, bucketSize: bucketSize)
            if var existing = dataPoints[bucketDate] {
                existing.transactions += abs(transaction.amount)
                dataPoints[bucketDate] = existing
            } else {
                dataPoints[bucketDate] = (0.0, abs(transaction.amount))
            }
        }

        // Convert to SpendingDataPoint array
        let sortedPoints = dataPoints.sorted { $0.key < $1.key }
        let totalAverage = dataPoints.values.map { $0.subscriptions + $0.transactions }.reduce(0, +) / Double(max(dataPoints.count, 1))

        return sortedPoints.map { date, amounts in
            let totalAmount = amounts.subscriptions + amounts.transactions
            let isSignificant = totalAmount > (totalAverage * 1.5)
            let annotation = isSignificant ? "High spending" : nil

            return SpendingDataPoint(
                date: date,
                amount: totalAmount,
                subscriptionsAmount: amounts.subscriptions,
                transactionsAmount: amounts.transactions,
                isSignificant: isSignificant,
                annotation: annotation
            )
        }
    }

    // MARK: - AGENT 6: Category Breakdown

    /// Calculate category breakdown for subscriptions and transactions
    func calculateCategoryBreakdown() -> [CategorySpending] {
        var categoryTotals: [String: (amount: Double, count: Int)] = [:]

        // Process active subscriptions
        let activeSubscriptions = dataManager.subscriptions.filter { $0.isActive }
        for subscription in activeSubscriptions {
            let categoryName = subscription.category.rawValue
            let monthlyAmount = subscription.monthlyEquivalent

            if var existing = categoryTotals[categoryName] {
                existing.amount += monthlyAmount
                existing.count += 1
                categoryTotals[categoryName] = existing
            } else {
                categoryTotals[categoryName] = (monthlyAmount, 1)
            }
        }

        // Calculate total for percentages
        let total = categoryTotals.values.reduce(0.0) { $0 + $1.amount }

        // Convert to CategorySpending array
        return categoryTotals.map { categoryName, data in
            let percentage = total > 0 ? (data.amount / total) * 100 : 0

            // Find matching category for color and icon
            let category = SubscriptionCategory.allCases.first { $0.rawValue == categoryName } ?? .other

            return CategorySpending(
                category: categoryName,
                amount: data.amount,
                count: data.count,
                percentage: percentage,
                color: category.color,
                icon: category.icon
            )
        }.sorted { $0.amount > $1.amount }
    }

    // MARK: - AGENT 6: Year Over Year Comparison

    /// Calculate year-over-year comparison
    func calculateYearOverYear() -> YearOverYearComparison {
        let calendar = Calendar.current
        let now = Date()

        // Get date boundaries
        guard let thisYearStart = calendar.date(from: calendar.dateComponents([.year], from: now)),
              let lastYearStart = calendar.date(byAdding: .year, value: -1, to: thisYearStart),
              let lastYearEnd = calendar.date(byAdding: .day, value: -1, to: thisYearStart) else {
            return createEmptyYoYComparison()
        }

        // This year calculations
        let thisYearTransactions = dataManager.transactions.filter {
            $0.date >= thisYearStart && $0.date <= now
        }
        let thisYearTotal = thisYearTransactions.reduce(0.0) { $0 + abs($1.amount) }
        let thisYearMonthsPassed = calendar.dateComponents([.month], from: thisYearStart, to: now).month ?? 1
        let thisYearMonthlyAvg = thisYearTotal / Double(max(thisYearMonthsPassed, 1))

        // Last year calculations
        let lastYearTransactions = dataManager.transactions.filter {
            $0.date >= lastYearStart && $0.date <= lastYearEnd
        }
        let lastYearTotal = lastYearTransactions.reduce(0.0) { $0 + abs($1.amount) }
        let lastYearMonthlyAvg = lastYearTotal / 12.0

        // Percentage change
        let percentageChange = lastYearTotal > 0 ? ((thisYearTotal - lastYearTotal) / lastYearTotal) * 100 : 0

        // Subscription counts
        let thisYearSubs = dataManager.subscriptions.filter {
            $0.createdDate >= thisYearStart
        }.count
        let lastYearSubs = dataManager.subscriptions.filter {
            $0.createdDate >= lastYearStart && $0.createdDate < thisYearStart
        }.count

        // Category growth analysis
        let (growing, declining) = calculateCategoryGrowth(
            thisYearTransactions: thisYearTransactions,
            lastYearTransactions: lastYearTransactions
        )

        return YearOverYearComparison(
            thisYearTotal: thisYearTotal,
            lastYearTotal: lastYearTotal,
            percentageChange: percentageChange,
            thisYearMonthlyAverage: thisYearMonthlyAvg,
            lastYearMonthlyAverage: lastYearMonthlyAvg,
            thisYearSubscriptionCount: thisYearSubs,
            lastYearSubscriptionCount: lastYearSubs,
            growingCategories: growing,
            decliningCategories: declining
        )
    }

    // MARK: - AGENT 6: Unused Subscriptions Detection

    /// Detect subscriptions that appear to be unused
    func detectUnusedSubscriptions() -> [Subscription] {
        let now = Date()
        let calendar = Calendar.current

        return dataManager.subscriptions.filter { subscription in
            guard subscription.isActive else { return false }

            // Check if never used
            if subscription.usageCount == 0 {
                return true
            }

            // Check if not used in 30+ days
            if let lastUsed = subscription.lastUsedDate {
                let daysSinceUse = calendar.dateComponents([.day], from: lastUsed, to: now).day ?? 0
                if daysSinceUse > 30 {
                    return true
                }
            }

            // Check if no linked transactions in 60+ days
            let linkedTransactions = dataManager.transactions.filter {
                $0.linkedSubscriptionId == subscription.id
            }

            if let lastTransaction = linkedTransactions.max(by: { $0.date < $1.date }) {
                let daysSinceTransaction = calendar.dateComponents([.day], from: lastTransaction.date, to: now).day ?? 0
                if daysSinceTransaction > 60 {
                    return true
                }
            } else if !linkedTransactions.isEmpty {
                // Has transactions but none recent
                return true
            }

            return false
        }
    }

    // MARK: - AGENT 6: Savings Opportunities

    /// Calculate potential savings opportunities
    func calculateSavingsOpportunities() -> [SavingsSuggestion] {
        var suggestions: [SavingsSuggestion] = []

        // 1. Unused subscriptions
        let unused = detectUnusedSubscriptions()
        for subscription in unused {
            suggestions.append(SavingsSuggestion(
                type: .unusedSubscription,
                title: "Cancel \(subscription.name)?",
                description: "No usage detected in the last 30 days",
                potentialSavings: subscription.monthlyEquivalent * 12,
                subscriptionId: subscription.id,
                priority: .high
            ))
        }

        // 2. Switch to annual plans
        let monthlySubscriptions = dataManager.subscriptions.filter {
            $0.isActive && $0.billingCycle == .monthly && $0.price >= 10
        }

        for subscription in monthlySubscriptions {
            // Estimate 20% savings with annual plan (industry standard)
            let annualSavings = subscription.price * 12 * 0.20
            suggestions.append(SavingsSuggestion(
                type: .switchToAnnual,
                title: "Switch \(subscription.name) to annual",
                description: "Save approximately 20% with annual billing",
                potentialSavings: annualSavings,
                subscriptionId: subscription.id,
                priority: annualSavings > 50 ? .medium : .low
            ))
        }

        // 3. Trials ending soon
        let trialsEnding = getTrialsEndingSoon(within: 7)
        for subscription in trialsEnding {
            let costAfterTrial = subscription.priceAfterTrial ?? subscription.price
            suggestions.append(SavingsSuggestion(
                type: .trialEnding,
                title: "\(subscription.name) trial ends soon",
                description: "Will charge \(formatCurrency(costAfterTrial)) after trial",
                potentialSavings: costAfterTrial,
                subscriptionId: subscription.id,
                priority: .high
            ))
        }

        // 4. Price increases (mock - would need price history tracking)
        // For now, we'll skip this as it requires historical data

        // Sort by potential savings (highest first)
        return suggestions.sorted { $0.potentialSavings > $1.potentialSavings }
    }

    // MARK: - AGENT 6: Spending Forecast

    /// Forecast spending for the next N months using linear regression
    func forecastSpending(months: Int) -> [ForecastValue] {
        let historicalData = calculateSpendingTrends(for: .year)

        guard historicalData.count >= 3 else {
            // Not enough data for forecast
            return []
        }

        // Simple linear regression
        let (slope, intercept) = calculateLinearRegression(data: historicalData)

        // Generate forecasts
        var forecasts: [ForecastValue] = []
        let calendar = Calendar.current
        var forecastDate = Date()

        for month in 1...months {
            forecastDate = calendar.date(byAdding: .month, value: month, to: Date()) ?? Date()

            // Predict using linear model
            let x = Double(historicalData.count + month)
            let predicted = slope * x + intercept

            // Calculate confidence interval (±15% for simplicity)
            let margin = predicted * 0.15

            forecasts.append(ForecastValue(
                date: forecastDate,
                predictedAmount: max(0, predicted),
                confidenceLow: max(0, predicted - margin),
                confidenceHigh: predicted + margin
            ))
        }

        return forecasts
    }

    // MARK: - AGENT 6: Subscription Analytics

    /// Get comprehensive subscription statistics
    func getSubscriptionStatistics() -> SubscriptionStatisticsData {
        let activeSubscriptions = dataManager.subscriptions.filter { $0.isActive }

        // Calculate totals
        let totalMonthly = activeSubscriptions.reduce(0.0) { $0 + $1.monthlyEquivalent }
        let totalYearly = totalMonthly * 12
        let averageCost = activeSubscriptions.isEmpty ? 0 : totalMonthly / Double(activeSubscriptions.count)

        // Get rankings
        let mostExpensive = getMostExpensiveSubscriptions(limit: 5)
        let leastUsed = getLeastUsedSubscriptions(limit: 5)
        let recentlyAdded = getRecentlyAddedSubscriptions(limit: 5)
        let trialsEnding = getTrialsEndingSoon(within: 7)

        return SubscriptionStatisticsData(
            totalActive: activeSubscriptions.count,
            totalMonthly: totalMonthly,
            totalYearly: totalYearly,
            averageCost: averageCost,
            mostExpensive: convertToAnalytics(mostExpensive),
            leastUsed: convertToAnalytics(leastUsed),
            recentlyAdded: convertToAnalytics(recentlyAdded),
            trialsEnding: convertToAnalytics(trialsEnding)
        )
    }

    /// Get trend analysis for current spending
    func getTrendAnalysis(for dateRange: DateRange) -> TrendAnalysis {
        let data = calculateSpendingTrends(for: dateRange)

        guard data.count >= 2 else {
            return TrendAnalysis(slope: 0, percentageChange: 0, isIncreasing: false, prediction: 0)
        }

        let (slope, intercept) = calculateLinearRegression(data: data)

        // Calculate percentage change from first to last
        let firstAmount = data.first?.amount ?? 0
        let lastAmount = data.last?.amount ?? 0
        let percentageChange = firstAmount > 0 ? ((lastAmount - firstAmount) / firstAmount) * 100 : 0

        // Predict next period
        let prediction = slope * Double(data.count + 1) + intercept

        return TrendAnalysis(
            slope: slope,
            percentageChange: percentageChange,
            isIncreasing: slope > 0,
            prediction: max(0, prediction)
        )
    }

    // MARK: - Private Helper Methods

    private func determineBucketSize(for dateRange: DateRange) -> (component: Calendar.Component, days: Int) {
        switch dateRange {
        case .week:
            return (.day, 1)
        case .month:
            return (.day, 1)
        case .quarter:
            return (.weekOfYear, 7)
        case .year:
            return (.month, 30)
        case .custom:
            return (.weekOfYear, 7)
        }
    }

    private func bucketDate(for date: Date, bucketSize: (component: Calendar.Component, days: Int)) -> Date {
        let calendar = Calendar.current

        switch bucketSize.component {
        case .day:
            return calendar.startOfDay(for: date)
        case .weekOfYear:
            return calendar.date(from: calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: date)) ?? date
        case .month:
            return calendar.date(from: calendar.dateComponents([.year, .month], from: date)) ?? date
        default:
            return date
        }
    }

    private func calculateLinearRegression(data: [SpendingDataPoint]) -> (slope: Double, intercept: Double) {
        let n = Double(data.count)
        guard n > 0 else { return (0, 0) }

        var sumX = 0.0
        var sumY = 0.0
        var sumXY = 0.0
        var sumX2 = 0.0

        for (index, point) in data.enumerated() {
            let x = Double(index)
            let y = point.amount
            sumX += x
            sumY += y
            sumXY += x * y
            sumX2 += x * x
        }

        let denominator = (n * sumX2 - sumX * sumX)
        guard denominator != 0 else { return (0, sumY / n) }

        let slope = (n * sumXY - sumX * sumY) / denominator
        let intercept = (sumY - slope * sumX) / n

        return (slope, intercept)
    }

    private func calculateCategoryGrowth(
        thisYearTransactions: [Transaction],
        lastYearTransactions: [Transaction]
    ) -> (growing: [CategoryGrowth], declining: [CategoryGrowth]) {
        var thisYearByCategory: [String: Double] = [:]
        var lastYearByCategory: [String: Double] = [:]

        // Group this year
        for transaction in thisYearTransactions {
            let category = transaction.category.rawValue
            thisYearByCategory[category, default: 0] += abs(transaction.amount)
        }

        // Group last year
        for transaction in lastYearTransactions {
            let category = transaction.category.rawValue
            lastYearByCategory[category, default: 0] += abs(transaction.amount)
        }

        // Calculate growth
        var allGrowth: [CategoryGrowth] = []
        let allCategories = Set(thisYearByCategory.keys).union(Set(lastYearByCategory.keys))

        for category in allCategories {
            let thisYear = thisYearByCategory[category] ?? 0
            let lastYear = lastYearByCategory[category] ?? 0
            let change = lastYear > 0 ? ((thisYear - lastYear) / lastYear) * 100 : 0

            let transactionCategory = TransactionCategory.allCases.first { $0.rawValue == category } ?? .other

            allGrowth.append(CategoryGrowth(
                category: category,
                thisYear: thisYear,
                lastYear: lastYear,
                percentageChange: change,
                color: transactionCategory.color
            ))
        }

        // Sort and split
        let sorted = allGrowth.sorted { $0.percentageChange > $1.percentageChange }
        let growing = Array(sorted.filter { $0.percentageChange > 5 }.prefix(5))
        let declining = Array(sorted.filter { $0.percentageChange < -5 }.suffix(5))

        return (growing, declining)
    }

    private func createEmptyYoYComparison() -> YearOverYearComparison {
        return YearOverYearComparison(
            thisYearTotal: 0,
            lastYearTotal: 0,
            percentageChange: 0,
            thisYearMonthlyAverage: 0,
            lastYearMonthlyAverage: 0,
            thisYearSubscriptionCount: 0,
            lastYearSubscriptionCount: 0,
            growingCategories: [],
            decliningCategories: []
        )
    }

    private func getMostExpensiveSubscriptions(limit: Int) -> [Subscription] {
        return dataManager.subscriptions
            .filter { $0.isActive }
            .sorted { $0.monthlyEquivalent > $1.monthlyEquivalent }
            .prefix(limit)
            .map { $0 }
    }

    private func getLeastUsedSubscriptions(limit: Int) -> [Subscription] {
        return dataManager.subscriptions
            .filter { $0.isActive }
            .sorted { $0.usageCount < $1.usageCount }
            .prefix(limit)
            .map { $0 }
    }

    private func getRecentlyAddedSubscriptions(limit: Int) -> [Subscription] {
        return dataManager.subscriptions
            .filter { $0.isActive }
            .sorted { $0.createdDate > $1.createdDate }
            .prefix(limit)
            .map { $0 }
    }

    private func getTrialsEndingSoon(within days: Int) -> [Subscription] {
        let calendar = Calendar.current
        let now = Date()

        return dataManager.subscriptions.filter { subscription in
            guard subscription.isFreeTrial,
                  let endDate = subscription.trialEndDate else {
                return false
            }

            let daysUntilEnd = calendar.dateComponents([.day], from: now, to: endDate).day ?? 0
            return daysUntilEnd >= 0 && daysUntilEnd <= days
        }.sorted { ($0.trialEndDate ?? Date.distantFuture) < ($1.trialEndDate ?? Date.distantFuture) }
    }

    private func convertToAnalytics(_ subscriptions: [Subscription]) -> [SubscriptionAnalytics] {
        return subscriptions.map { subscription in
            SubscriptionAnalytics(
                id: subscription.id,
                name: subscription.name,
                monthlyAmount: subscription.monthlyEquivalent,
                yearlyAmount: subscription.monthlyEquivalent * 12,
                billingCycle: subscription.billingCycle.rawValue,
                category: subscription.category.rawValue,
                icon: subscription.icon,
                color: subscription.color,
                usageCount: subscription.usageCount,
                lastUsedDate: subscription.lastUsedDate,
                createdDate: subscription.createdDate,
                isFreeTrial: subscription.isFreeTrial,
                trialEndDate: subscription.trialEndDate
            )
        }
    }

    private func formatCurrency(_ amount: Double) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.currencySymbol = "$"
        return formatter.string(from: NSNumber(value: amount)) ?? "$0.00"
    }
}

// MARK: - AGENT 6: Sample Data Generator

extension AnalyticsService {
    /// Generate sample spending data for demonstration
    func generateSampleData(months: Int = 12) -> [SpendingDataPoint] {
        var dataPoints: [SpendingDataPoint] = []
        let calendar = Calendar.current

        for month in 0..<months {
            let date = calendar.date(byAdding: .month, value: -months + month, to: Date()) ?? Date()

            // Generate realistic variation
            let baseAmount = 1500.0
            let variation = Double.random(in: -300...500)
            let subscriptionsAmount = 800.0 + Double.random(in: -100...200)
            let transactionsAmount = baseAmount + variation - subscriptionsAmount

            let isSignificant = variation > 300

            dataPoints.append(SpendingDataPoint(
                date: date,
                amount: subscriptionsAmount + transactionsAmount,
                subscriptionsAmount: subscriptionsAmount,
                transactionsAmount: transactionsAmount,
                isSignificant: isSignificant,
                annotation: isSignificant ? "High spending month" : nil
            ))
        }

        return dataPoints
    }
}
